# import streamlit as st
# import pandas as pd
# import pickle
# from sklearn.ensemble import RandomForestRegressor

# # Load the trained model
# model_path = 'random_forest_model.pkl'
# with open(model_path, 'rb') as file:
#     model_rf = pickle.load(file)

# # Function to predict based on user inputs
# def predict_btc_price(input_data):
#     # Make prediction using the model
#     prediction = model_rf.predict(input_data)
#     return prediction[0]  # Assuming model returns a single prediction

# def main():
#     # Title of your web app
#     st.title('Predict BTC Close Price')

#     # Sidebar for user inputs
#     st.sidebar.title('Input Features')
    
#     # Inputs for USDT, BNB closing prices and volumes
#     usdt_close = st.sidebar.number_input('USDT Close Price', min_value=0.0, format="%.2f")
#     usdt_volume = st.sidebar.number_input('USDT Volume', min_value=0.0, format="%.2f")
#     bnb_close = st.sidebar.number_input('BNB Close Price', min_value=0.0, format="%.2f")
#     bnb_volume = st.sidebar.number_input('BNB Volume', min_value=0.0, format="%.2f")

#     # Create input dataframe
#     input_data = pd.DataFrame({
#         'USDT_Close': [usdt_close],
#         'USDT_Volume': [usdt_volume],
#         'BNB_Close': [bnb_close],
#         'BNB_Volume': [bnb_volume]
#     })

#     # Button to trigger prediction
#     if st.button('Predict BTC Close Price'):
#         predicted_price = predict_btc_price(input_data)
#         st.write('Predicted BTC Close Price:', predicted_price)

# if __name__ == '__main__':
#     main()

# The Above code is sir code Senapati Sir Code
# Below code is my code

import streamlit as st
import pickle
import pandas as pd
import base64
import time
from datetime import datetime
from sklearn.metrics import mean_squared_error, r2_score

# ================================
# üéØ CONFIGURATION
# ================================
# NOTE: The model path MUST match the file generated by your notebook.
MODEL_PATH = "random_forest_model.pkl" 
FEATURE_NAMES = ['USDT_Close', 'USDT_Volume', 'BNB_Close', 'BNB_Volume']

# BASE64 FALLBACK IMAGE (Crypto-themed Dark/Blue Grid)
BASE64_FALLBACK_IMAGE = """
data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSI4MDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+
 <rect width="1200" height="800" fill="#0c1221"/>
 <rect x="50" y="50" width="1100" height="700" stroke="#ff9900" stroke-width="5" fill="none" stroke-opacity="0.3"/>
 <rect x="100" y="100" width="500" height="200" fill="rgba(255, 153, 0, 0.05)" rx="10" ry="10"/>
 <rect x="600" y="400" width="500" height="300" fill="rgba(255, 153, 0, 0.08)" rx="10" ry="10"/>
 <line x1="50" y1="750" x2="1150" y2="50" stroke="#00bfff" stroke-width="2" stroke-opacity="0.1"/>
 <circle cx="600" cy="400" r="100" fill="rgba(0, 191, 255, 0.05)"/>
 <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif" font-size="60" fill="rgba(255, 153, 0, 0.2)">CRYPTO ML</text>
</svg>
"""

# ================================
# ‚öôÔ∏è UTILITIES
# ================================

def get_base64_image_url(uploaded_file):
    """Reads an uploaded file and converts it to a Base64 data URL."""
    try:
        bytes_data = uploaded_file.getvalue()
        base64_encoded_data = base64.b64encode(bytes_data).decode('utf-8')
        mime_type = uploaded_file.type if uploaded_file.type else "image/png"
        return f"data:{mime_type};base64,{base64_encoded_data}"
    except Exception as e:
        st.error(f"Error processing image: {e}")
        return None

# ================================
# üåÑ CINEMATIC BACKGROUND SLIDESHOW
# ================================

def set_cinematic_bg(base64_urls, interval_per_image=6):
    """Applies a smooth crossfading background slideshow using Base64 URLs."""
    num_images = len(base64_urls)
    total_duration = num_images * interval_per_image
    OVERLAY_OPACITY = "rgba(0,0,0,0.65)" 

    # --- CSS Selectors for Frosted Glass Effect on containers ---
    FROSTED_GLASS_SELECTORS = """
        [data-testid="stSidebar"] > div:first-child,
        [data-testid="stTabs"] > div:nth-child(2)
    """

    if num_images == 0:
        st.info("No images uploaded. Using a static deep-space grid background.")
        
        # --- FALLBACK CSS: Base64 Embedded Image (Static) ---
        st.markdown(f"""
            <style>
            .stApp {{
                background-image: url('{BASE64_FALLBACK_IMAGE.replace('\n', '')}');
                background-attachment: fixed;
                background-size: cover;
                background-position: center;
                animation: none !important;
                color: white; /* Ensure text color is white for readability */
            }}
            .stApp::before {{
                content: "";
                position: fixed;
                top: 0; left: 0;
                width: 100%; height: 100%;
                background: {OVERLAY_OPACITY};
                z-index: 0;
            }}
            {FROSTED_GLASS_SELECTORS} {{
                background: rgba(255, 255, 255, 0.05); /* Subtle white frost */
                backdrop-filter: blur(8px);
                border-radius: 16px;
                padding: 20px;
                z-index: 10;
            }}
            </style>
        """, unsafe_allow_html=True)
        return

    # --- SUCCESS CSS: Image Slideshow (Dynamic) ---
    css_keyframes = []
    for i in range(num_images):
        start_percent = (i * 100) / num_images
        hold_percent = (start_percent + ((100 / num_images) * (1 - 1 / interval_per_image))) 
        
        css_keyframes.append(f"{start_percent:.2f}% {{ background-image: url('{base64_urls[i]}'); }}")
        if i < num_images - 1:
            css_keyframes.append(f"{hold_percent:.2f}% {{ background-image: url('{base64_urls[i]}'); }}")
    
    # Ensure the animation loops back smoothly
    css_keyframes.append(f"100% {{ background-image: url('{base64_urls[0]}'); }}")


    st.markdown(f"""
        <style>
        .stApp {{
            background-size: cover;
            background-attachment: fixed;
            background-repeat: no-repeat;
            background-image: url('{base64_urls[0]}');
            animation: cinematicBg {total_duration}s infinite;
            color: white; /* Ensure text color is white for readability */
        }}
        @keyframes cinematicBg {{
            {"".join(css_keyframes)}
        }}

        /* Apply a dark overlay for better readability and subtlety */
        .stApp::before {{
            content: "";
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: {OVERLAY_OPACITY};
            z-index: 0;
        }}
        
        /* Frosted glass content containers (Sidebar and Tabs) */
        {FROSTED_GLASS_SELECTORS} {{
            background: rgba(255, 255, 255, 0.05); /* Subtle white frost */
            backdrop-filter: blur(8px);
            border-radius: 16px;
            padding: 20px;
            z-index: 10;
        }}

        /* General styling adjustments */
        * {{ color: white; font-family: 'Inter', sans-serif; }}
        
        /* Prediction box styling */
        .prediction-box h2, .prediction-box h1, .prediction-box p {{
            color: inherit !important;
        }}
        
        [data-testid="stHeader"], [data-testid="stToolbar"] {{ background: transparent !important; }}
        
        </style>
    """, unsafe_allow_html=True)

# ================================
# üìå LOAD MODEL
# ================================
model_rf = None
R2_SCORE = 0.985 # Mock values for Model Info tab
MSE_SCORE = 15.7 # Mock values for Model Info tab

try:
    with open(MODEL_PATH, "rb") as f:
        model_rf = pickle.load(f)
    # The following values are mock placeholders. Please replace them 
    # with the actual R2 and MSE values from your training notebook.
    st.info("Model loaded successfully: Random Forest Regressor is ready.")
except FileNotFoundError:
    st.error(f"‚ùå Model file '{MODEL_PATH}' not found. Please ensure your notebook has created it.")
except Exception as e:
    st.error(f"‚ö†Ô∏è Error loading model: {e}")

# ================================
# üìå SIDEBAR CONTENT (Includes Image Uploader)
# ================================

base64_image_urls = []
with st.sidebar:
    st.title("üõ†Ô∏è App Configuration")
    
    # --- IMAGE UPLOADER ---
    st.subheader("üñºÔ∏è Background Images")
    uploaded_files = st.file_uploader(
        "Upload images (JPG/PNG) for the slideshow:",
        type=["jpg", "jpeg", "png"],
        accept_multiple_files=True,
        help="Use images related to crypto, finance, or technology for best effect."
    )
    
    if uploaded_files:
        if len(uploaded_files) < 3:
            st.info("Upload at least 3 images for a smoother crossfade slideshow.")
        
        with st.spinner(f"Processing {len(uploaded_files)} image(s)..."):
            for file in uploaded_files:
                url = get_base64_image_url(file)
                if url:
                    base64_image_urls.append(url)
            time.sleep(0.5)

    st.markdown("---")
    st.subheader("Model Info")
    st.info("This application uses a Random Forest Regressor trained on multi-asset crypto data.")
    st.markdown(
        "üìÖ Last Updated: **" + datetime.now().strftime('%b %d, %Y') + "**"
    )

# Apply background logic (using images uploaded in the sidebar)
set_cinematic_bg(base64_image_urls)

# ================================
# üí∞ HEADER (Main Screen)
# ================================
st.set_page_config(layout="wide")
st.markdown("<h1 style='text-align:center; color:#FF9900; text-shadow: 2px 2px 6px #000000;'>‚ö° CryptoPulse: BTC Price Forecast</h1>", unsafe_allow_html=True)
st.markdown("<p style='text-align:center; font-size:18px; color:#F0F0F0;'>Harnessing Random Forest to predict Bitcoin's close price based on key market indicators.</p>", unsafe_allow_html=True)

# ================================
# üìä TABS (Main Screen)
# ================================
tab1, tab2 = st.tabs(["üîë Real-time Prediction", "üìà Model Analytics"])

# ================================
# ‚ú® TAB 1 ‚Äî PREDICTION
# ================================
with tab1:
    st.header("Enter Supporting Asset Market Data")

    if model_rf:
        
        # Inputs are split into two columns
        col1, col2 = st.columns(2)

        # Collect user inputs
        with col1:
            # USDT inputs (Stablecoin, proxy for liquidity/safety)
            usdt_close = st.number_input("üí≤ USDT Close Price (Current)", 0.0, 10.0, 1.0001, format="%.4f")
            usdt_volume = st.number_input("üìä USDT Volume (Millions)", 0.0, 10000.0, 500.00, step=10.0)

        with col2:
            # BNB inputs (Exchange Coin, proxy for exchange health/activity)
            bnb_close = st.number_input("üí∞ BNB Close Price (Current)", 0.0, 5000.0, 350.50, format="%.2f")
            bnb_volume = st.number_input("üìà BNB Volume (Millions)", 0.0, 5000.0, 120.00, step=1.0)

        st.markdown("---")

        if st.button("üöÄ PREDICT BTC CLOSE PRICE", use_container_width=True, type="primary"):
            
            # Input Validation
            if any(val <= 0.0 for val in [usdt_close, bnb_close, usdt_volume, bnb_volume]):
                st.warning("Please ensure all inputs (price and volume) are greater than zero.")
                st.stop() # <-- FIX: Use st.stop() to halt script execution instead of 'return'
            
            # Prepare data as a Pandas DataFrame with correct column names and assumed scaling
            # Assuming the model was trained with the actual large volume numbers,
            # we convert the 'Millions' input back to a large number.
            input_data = [
                usdt_close, 
                usdt_volume * 1_000_000, 
                bnb_close, 
                bnb_volume * 1_000_000
            ]
            features_df = pd.DataFrame([input_data], columns=FEATURE_NAMES)
            
            try:
                with st.spinner("Analyzing market signals..."):
                    time.sleep(1) # Simulate network delay for effect
                    prediction = model_rf.predict(features_df)
                    st.balloons()
                    
                    # Display the prediction result with high impact styling
                    st.markdown(f"""
                        <div class="prediction-box" style="background-color:rgba(255, 153, 0, 0.9); padding:30px; border-radius:15px; text-align:center; margin-top: 30px; box-shadow: 0 0 20px #ff9900;">
                            <h2 style="color:#1a1a2e; margin-bottom: 5px;">‚úÖ FORECAST SUCCESSFUL</h2>
                            <h1 style="color:white; font-size: 4em;">${prediction[0]:,.2f}</h1>
                            <p style="color:#1a1a2e;">Predicted BTC Close Price (Next Day/Period)</p>
                        </div>
                    """, unsafe_allow_html=True)
            except Exception as e:
                st.error(f"Prediction failed: {e}")
    else:
        st.warning("‚ö†Ô∏è Prediction feature unavailable due to model loading error.")

# ================================
# üìä TAB 2 ‚Äî MODEL INFO
# ================================
with tab2:
    st.header("Model Overview & Performance")

    st.subheader("üìå Algorithm Used")
    st.info("**Random Forest Regressor** - Highly effective for capturing non-linear relationships in time series data.")

    st.subheader("üß∞ Training Features")
    st.markdown("""
    The model predicts Bitcoin's closing price by analyzing the concurrent closing prices and trading volumes of major supporting assets:
    - `USDT_Close`, `USDT_Volume`
    - `BNB_Close`, `BNB_Volume`
    """, unsafe_allow_html=True)

    st.subheader("üìä Performance Metrics")
    
    if model_rf:
        col1, col2, col3 = st.columns(3)
        # Please replace these mock values with the actual results from your notebook!
        col1.metric("R-squared (R¬≤)", f"{R2_SCORE:.3f}", delta="High Correlation")
        col2.metric("Mean Squared Error (MSE)", f"{MSE_SCORE:.1f}", delta="Low Error")
        col3.metric("Model Type", "Random Forest", delta="Regressor")
        st.caption("Note: R¬≤ and MSE are placeholder values. Please update them based on your model's actual performance.")
    else:
        st.warning("Performance metrics are unavailable because the model failed to load.")

if __name__ == '__main__':
    pass
